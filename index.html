<!DOCTYPE html>
<html lang='en'
      id="home">

<head>
  <meta charset='UTF-8' />
  <title>Twiddler</title>
  <link href="./assets/css/main.css"
        rel="stylesheet">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- <meta http-equiv="refresh"
        content=40> -->
  <link href="http://fonts.googleapis.com/css?family=Lato:100,300,400">
  <title>Twiddler</title>
</head>

<body>
  <header>
    <div class="parent-nav">
      <div class="nav">
        <div class="nav-item1">
          <h1> Twiddler
            <!--stacked twitter icon-->
            <i class="fa-stack fa-lg">
              <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
              <i class="fa fa-circle-thin fa-stack-2x fa-inverse"></i>
            </i>
          </h1>
        </div>
        <div class="nav-item2">
          <ul class="nav-bar">
            <li><a href="#home"> home</a></li>
            <li>placeholder</li>
            <li>plceholder</li>
          </ul>
        </div>
        <div class="nav-item3"></div>
        <div class="nav-item4">
          <button class="btn tweet-btn tweet-btn--primary"> Compose a Twidder! </button>
        </div>
        <!-- <div class="nav-item5">placeholders</div>
        <div class="nav-item6">placeholders</div> -->
      </div>
    </div>
  </header>
  <script src="data_generator.js"></script>
  <script src="jquery.js"></script>
  <!-- <script src="./test.js"></script> -->

  <script>
    
    $(document).ready(function () {

      var $body = $('body');
      // $body.html('');
      //can i just return the function implementation?
      // var something = (function () {
      //   var foo = function (index) {
      //     var tweet = streams.home[index];

      //     $('<p>' + tweet.user + '</p>').appendTo($(".logo"));
      //   }
      //   return {
      //     foo: foo,
      //   };
      // })();
      const fStore = {
        //helper functions
        tweetPastCount: 0,
        tweetCurrentCount: 0,
        
        //because of the async stuff involved, lets keep everyone using the same streams.home.
        getCurrentCount: function () { 
          return streams.home.length;
        },
        
        //get the correct loopign time.
        setCurrentCount: function (number = streams.home.length) { 
          this.tweetCurrentCount = number;
        },

        setPastCount: function (number) {
          this.tweetPastCount = number;
        },

        getter1: function () {
          return this.tweetPastCount;
        },
        getter2: function () {
          return this.tweetCurrentCount;
        },

        getDiffCount: function () {
           return Math.abs(this.getter2() - this.getter1());
        },

        // getPastCount: function () {
        //   return this.tweetPastCount;
        // },
        
        // getCurrentCount: function () {
        //   return this.tweetCurrentCount;
        // },


        formatter: function (elementStr, messageStr, className, destination) {
          var formatted = '<' + elementStr + ' ' + 'class='
            + '"'
            + className
            + '"'
            + '>'
            + messageStr
            + '</' + elementStr +'>';
            return formatted;
        },
        //
        showTweet: function (index) {
          var tweet = streams.home[index];
          var tweetContClass = `.tweet-container`;
          

          
          //collate the content.
          var formatUser = this.formatter('a', tweet.user, 'filter-by tweet-user', tweetContClass);

          var formatMessage = this.formatter('p', tweet.message, 'tweet-text', tweetContClass);

          var formatTime = this.formatter(`button value=${tweet.created_at.getTime()} type="button" disabled`, tweet.created_at.getTime(), 'tweet-date', tweetContClass);
          this.updateTime();

          var combinedTweetContent = formatUser + formatMessage + formatTime;
          
          //put content into a class called tweet-container. slice away the .
          var $tweetCont = $(`<div class=${tweetContClass.slice(1)}>${combinedTweetContent}</div>`);
          
          //jquery it out to .tweet-bar;
          if( index < 10 ) {
          $tweetCont.appendTo('.tweet-bar'); 
          }  else {
            $tweetCont.prependTo('.tweet-bar');
          }
          $tweetCont.animate( {opacity : .35}, 110000);
         
          //have to use this to ignore the runningbackwards index.
          if (this.tweetPastCount < index) {
            this.setPastCount(index);
          }
          //i want to append the 10th one the latest one to the top.

          $('.tweet-user').click( (e) => {
            var userName=$(e.target).text();
            // alert($(this).attr('setid'));
            // $('tweet').eq(1).slideUp();
            fStore.filterByName(userName); 
          });

          // this.updateTime();
        },

        showTweetLooper: function() { 
          this.updateTime();
          //so my divider doesnt get spammed.
          if ((document.getElementsByClassName("tweet-bar")[0].firstChild.classList[0] !== 'tweet-divider') && this.getDiffCount() > 5) {
            
            $("<div class='tweet-divider'>Past Tweets</p>").prependTo('.tweet-bar');   
          }
          // alert(this.getDiffCount());
          // if (!($('.tweet-bar').first('.tweet-divider'))) {
          
          //i want to prepend each one abovethe tweets.
          //tweet 11, then 12 then 13
          // this.setCurrentCount();
          for (var i = this.tweetPastCount+1; i <= this.tweetCurrentCount; ++i) {
            this.showTweet(i);
          }
          $('.tweet-container').show();
          this.updateTweetCount();
        },

        //this creates a forever loop where the counts are always being updated.
        everSet: function() {
          this.updateTime();
          $('.threeof5').text(this.tweetCurrentCount+' '+this.tweetPastCount);
          this.updateTweetCount('.refresh-count');
          setInterval( () => {
            this.updateTime();
          }, 6000);

          setTimeout( () => { 
            this.setCurrentCount(); 
            this.everSet();
            // this.updateTime();
          },4000);
          
        },

        updateTweetCount: function(className = '.refresh-count') {
          var diffCount = Math.abs(this.tweetCurrentCount - this.tweetPastCount);
          $('.refresh-count').replaceWith(`<p class="refresh-count">${diffCount}</p>`);
          // this.updateTime();
        },

        clearTweetBar: function() {
          $('.tweet-bar').hide();
        },
        
        showTweetBar: function() {
          $('.tweet-bar').show();
          $('.tweet-container').show();
        },

        updateTime: function() {
          const now = new Date();
          var x = document.getElementsByClassName('tweet-date');
          
          for (var i = 0, equationRes = 0; i < x.length; i++) {
            // x[1].childNodes[0].nodeValue = 5
            equationRes = ( now.getTime() - Number(x[i].value));
            console.log(equationRes);
            var answer = this.timeAgo(equationRes); 
            console.info('answer');             
            x[i].textContent = answer;
                      
          }
          //get now time, get then time, do some math
          //then find that specific one and update it.
        },

        timeAgo: function(equationRes) {
          equationRes /= 60000;
          if (equationRes >= 1 ) {
            return `About ${Math.floor(equationRes)} minutes ago`;
          } else {
            return `less than a minute ago.`;
          }
        },

        filterByName: (userName) => {
          //get name
          //select all tweet containers where the html!=@whoever.
          for (var i = 0; i < $('.tweet-container').length; ++i) {
            var bingo = $('.tweet-container').eq(i).find('.tweet-user').text();
            if (userName ===  bingo) {
              $('.tweet-container').eq(i).addClass('bingo');
            } else {
              $('.tweet-container').eq(i).hide();
            }

          }
          //this works but won't when i click on reloops.
          // $(`.tweet-user:not(:contains("${userName}"))`).parent().hide();
        }
      }
      //END of object functionStore.

      //this recursively adds. remember to do j. meyers workshop when i get
      //more ahead of this project.
      
      // $("*").addClass("debug-borders");
      
      var index = streams.home.length - 1;
      while (index >= 0) {


        fStore.showTweet(index);
        
        index -= 1;
      }

      $('.refresh-btn').click( () => { fStore.showTweetLooper(); });
      // $('.clear-btn').click( () => { fStore.clearTweetBar(); });
      // $('.tweet-btn').click( () => { fStore.showTweetBar(); });
      // $('.tweet-btn').click( () => { fStore.updateTime(); });
    
        
        fStore.everSet();
        // fStore.filterByName(); 
      
      // document.getElementsByTagName('.refresh-btn').onClick=fStore.showTweetLooper();;
      // setInterval( () => { fStore.setCurrentCount(); }, 13000);
      
      // let jack = something.foo(3);
    });


  </script>
  <section class="grid">
    <div class="row">
      <section class="col-1-3">
        <div class="col-1-3-top">
          <div class="logo">
            <div class="half-circle">
              <i class="fa fa-camera"></i>
            </div>
          </div>
          <div class="user-info">
            <div class="twoof5">User </div>
            <div class="threeof5">@userName</div>
          </div>
        </div>
      </section>
      <section class="content col-2-3">
        <div class="refresh-bar">
          <button class="btn refresh-btn">refresh</button>
          <span class="refresh-count"></span>
        </div>
        <div class="tweet-bar">
        </div>
      </section>
      <!-- <section class="col-1-3">
        <div>
        </div>
      </section> -->
    </div>
  </section>
</body>

</html>
<!--

          var $trendCont = $(`<li class="trend-container-${index}"></li>`);
          var $trendContClass = `.trend-container-${index}`;

          var $tweetCont = $(`<li class="tweet-container-${index}"></li>`);
          var $tweetContClass = `.tweet-container-${index}`;
          var $tweetTimeStamp = $(`<p>${streams.home[index].created_at}</p>`);

          //container for user, text, time stamp
          $tweetCont.appendTo(".tweet-bar");

          
          //content for tweet container
          $tweetUser.appendTo($tweetContClass);

          $tweetText.appendTo($tweetContClass);
          $tweetTimeStamp.appendTo($tweetContClass);
          
          //content for trend container
          
          //make sure that there is actually a hash before appending.
         

            //this obtains a tally of all the hash tags but it's not as useful as i like
            //without more data or more hash tags.
          $cacheTally = Object.assign($cacheTally, tweet.message.split(' ')
              .filter( item => item[0] === '#')
              .reduce( (accum, item) => {
                if (accum[item]) {
                  accum[item]++;
                } else {
                  accum[item] = 1;
                }
                return accum;
              },{})
              )
              //#consult hack-reactor guide.              
          
            
          index -= 1;
        }
        $trendCont.appendTo(".trend-bar");
        
        const showTrends = () => {
          for (let key in $cacheTally) {
            $(`<p class="trending-tag">${key}<p>`).appendTo($trendContClass);
          }  
        }


      });
    </script>

    okay some psuedo code
    structure
    <tweet-bar>
      <tweet-container-10>
      <t-c-9>
     ....
     Now i want to prepend the number of lists.
     How does datagenerator work anyway?
        okay there's  aforever loop in there. 

        my code
       setInterval(function() {
        console.log(streams.home.length) }
        ,1500);

        >> every time the length goes from 13, 14, 15, 16


        generator code
        var scheduleNextTweet = function(){
        generateRandomTweet();
        setTimeout(scheduleNextTweet, Math.random() * 1500);
        };
        scheduleNextTweet();

        it keeps generating more and more tweets every 1500s.
        I have to get the activate it pretty quickly. 
        1. get first 11 tweets.
        2. 1500 seconds go by.
        3. 1 more tweet. 
        4. no btn activation.
        5. more tweets.
        6. btn activate.
        7. grab the tweets.
        8. display them.

        1. get first 11.
        2. record the count of the original tweet Count : 10
        3. record the count of the current tweet count when button activates.
        4. let's say 50.
        5. create a loop from originalTC to currentTC and prepend that from 1 to 10. 

        1. create an old count and a new count
        2. create an event that will trigger the loop.
        3. create the loop function that will prepend.





        -->

        
